# Transaction propagation levels

Допустим, имеется 2 сервиса, аннотированные @Transactional, и один сервис использует методы второго.
Будет ли создано две транзакции, или же одна? Будет ли внутренний метод выбрасывать исключение, если
снаружи нет никакой транзакции? На эти вопросы и отвечает настройка propagation.

## Общий пример

```
@Transactional
class InnerService {

    public void foo() {
        // do something...
    }
    
}

@Transactional
class OuterService {

    private InnerService inner;

    public void callInner() {
        // do something...
        inner.foo();
        // do something...
    }
    
}
```

## Propagation.REQUIRED

По умолчанию подразумевается, что propagation=REQUIRED.

То есть объявление метода репозитория без propagation (как выше) равносильно следующему:

```
@Transactional(propagation = Propagation.REQUIRED)
class InnerService {

    public void foo() {
        // do something...
    }
    
}
```

При данной настройке для метода репозитория не создается отдельная транзакция, а метод выполняется
в рамках транзакции вызывающего метода *callInner()*.

Вообще propagation=REQUIRED задает следующее поведение:

1. Если метод InnerService::foo() вызывается вне транзакции, для него создается отдельная транзакция.
2. Если же InnerService::foo() вызывается из метода сервиса, в котором уже есть транзакция, то InnerService::foo()
   вызывается в рамках этой транзакции.

## Propagation.REQUIRED_NEW

В случае REQUIRED_NEW для внутреннего метода создается своя отдельная транзакция. Пока выполняется внутренний метод,
внешняя транзакция приостанавливается. Но это две отдельных транзакции, и исключение во внешнем методе не повлияет
на успешное подтверждение внутренней транзакции.

```
@Transactional(propagation = Propagation.REQUIRED_NEW)
class InnerService {

    public void foo() {
        // do something...
    }
    
}
```

Приостановку внешней транзакции можно представить следующим образом. Это как открыть две консоли Query Tool в pg_admin
и последовательно отправлять в эти две консоли команды:

```
1. begin; -- 1 консоль
 
2. OuterService SQL query; -- 1 консоль
 
3. begin;  -- 2 консоль

4. InnerService SQL query;  -- 2 консоль

5. commit;  -- 2 консоль

6. rollback(commit); -- 1 консоль
```

1 консоль относится к транзакции внешнего метода, а 2 консоль — внутреннего. Приостановка внешней транзакции
заключается в том, что rollback (либо commit) для нее (пункт 6) делается после того, как мы на время переключились
на 2 консоль внутреннего метода, и выполнили в ней все команды транзакции (пункты 3 — 5).

## Propagation.SUPPORTS

SUPPORTS использует транзакцию во внешнем методе, если она есть. Но если нет, своя транзакция для внутреннего метода
создаваться не будет. А без транзакции все команды внутреннего метода будут выполнены в режиме авто-фиксации (
AUTOCOMMIT).

В режиме AUTOCOMMIT каждая команда автоматически подтверждается (как бы обрамляется своей отдельной транзакцией —
commit-ом, происходит это на уровне базы данных). То есть, если бы в методе InnerService::foo() было несколько
SQL-операторов update, то в режиме AUTOCOMMIT часть из них могла бы выполниться, а часть — нет.

## Propagation.NOT_SUPPORTED

В отличие от SUPPORTS, здесь команды ускользают от транзакции, даже если вызываются в рамках ее. То есть, если внешний
метод аннотирован @Transactional, а в методе InnerService стоит NOT_SUPPORTED, то метод репозитория выполнится в
режиме AUTOCOMMIT.

```
@Transactional(propagation = Propagation.NOT_SUPPORTED)
class InnerService {

    public void foo() { -- Метод будет выполнен в режиме AUTOCOMMIT, и не будет включен во внешнюю транзакцию
        // do something...
    }
    
}
```

## Propagation.NEVER

Propagation.NEVER не терпит транзакции снаружи и выбрасывает исключение, если транзакция обнаружена. Таким образом,
внешняя транзакция тоже не выполнится.

## Propagation.MANDATORY

Propagation.MANDATORY требует внешнюю транзакцию, а иначе выбрасывается исключение.

## Итоги

Таким образом, метод InnerService::foo(), в зависимости от его настройки propagation и от того, откуда он вызывается,
ведет себя по-разному. В таблице показано поведение в случаях вызова метода из транзакции (левая колонка) и вне
транзакции (правая колонка).

|               | Вызов из OuterService::callInner()                                       | Отдельный вызов             |
|---------------|--------------------------------------------------------------------------|-----------------------------|
| REQUIRED      | используется существующая транзакция                                     | создается транзакция        |
| REQUIRED_NEW  | создается отдельная вторая транзакция для внутреннего метода             | создается транзакция        | 
| SUPPORTS      | используется существующая транзакция                                     | транзакция **не** создается |
| NOT_SUPPORTED | существующая транзакция не используется, код выполняется вне транзакции  | транзакция **не** создается |
| NEVER         | выбрасывает исключение                                                   | транзакция **не** создается |
| MANDATORY     | используется существующая транзакция                                     | выбрасывает исключение      |


